class AuthenticationResults
{
    private $hostname = "";
    private $authresult = [];

    constructor($opts = [])
    {
        $this->hostname = $opts["hostname"] ? $opts["hostname"] : gethostname();
    }

    function SPF($spf, $senderhelo, $senderdomain, $ptypes = none)
    {
        $this->authresult["spf"]["result"] = $spf["result"];
        $this->authresult["spf"]["ptype"] = $senderdomain ? ["smtp.mailfrom" => $senderdomain] : ["smtp.helo" => $senderhelo];

        if (is_array($ptypes)) $this->authresult["spf"]["ptype"] += $ptypes;
        return $this;
    }

    // draft-martin-authentication-results-tls-03

    function TLS($tls, $ptypes = none)
    {
        if (!$tls)
            $this->authresult["tls"]["result"] = "none";
        else
        {
            if (!$tls["peercert"])
                $this->authresult["tls"]["result"] = "fail (no client certificate)";
            else if ($tls["peercert"] and $tls["peercert"]["error"] == 0)
                $this->authresult["tls"]["result"] = "pass (verified)";
            else if ($tls["peercert"] and $tls["peercert"]["error"] == 10)
                $this->authresult["tls"]["result"] = "fail (expired)";
            else if ($tls["peercert"] and $tls["peercert"]["error"] == 19)
                $this->authresult["tls"]["result"] = "selfsigned";
            else
                $this->authresult["tls"]["result"] = "fail (unverified)";

            $this->authresult["tls"]["ptype"]["tls.v"] = $tls["protocol"];
            $this->authresult["tls"]["ptype"]["key.ciphersuite"] = $tls["cipher"];
            $this->authresult["tls"]["ptype"]["key.length"] = $tls["keysize"];

            if ($tls["peercert"])
            {
                $clientcert = X509($tls["peercert"]["x509"]);
                $this->authresult["tls"]["ptype"]["cert.client"] ="\"".
			pcre_replace(#/["\r\n]/, "",
				array_join(array_map(function ($x) { return $x[0]."=".$x[1]; }, $clientcert->subject()), ","))."\"";
                $alt = $clientcert->subject_alt_name();
                if ($alt["DNS"])
                    $this->authresult["tls"]["ptype"]["cert.clientalt"] = "\"".
			pcre_replace(#/["\r\n]/, "",
				array_join(array_map(function ($x) { return "DNS:".$x; }, $alt["DNS"]), ","))."\"";
                $this->authresult["tls"]["ptype"]["cert.clientissuer"] = "\"".
			pcre_replace(#/["\r\n]/, "",
				array_join(array_map(function ($x) { return $x[0]."=".$x[1]; }, $clientcert->issuer()), ","))."\"";
            }
        }

        if (is_array($ptypes)) $this->authresult["tls"]["ptype"] += $ptypes;
        return $this;
    }

    private function addDKIMSignature($dkimresult)
    {
        $dkim = ["result" => $dkimresult["result"], "ptype" => $ptypes ? $ptypes : []];
        if (isset($dkimresult["tags"]["d"]))
            $dkim["ptype"] += ["header.d" => $dkimresult["tags"]["d"]];
        if (isset($dkimresult["tags"]["s"]))
            $dkim["ptype"] += ["header.s" => $dkimresult["tags"]["s"]];
        if (isset($dkimresult["tags"]["a"]))
            $dkim["ptype"] += ["header.a" => $dkimresult["tags"]["a"]];
        if (isset($dkimresult["tags"]["b"]))
            $dkim["ptype"] += ["header.b" => pcre_replace(''/[\s\r\n]/'', "", $dkimresult["tags"]["b"])[:8]];
        $this->authresult["dkim"][] = $dkim;
        return $this;
    }

    function DKIM($mime, $ptypes = none)
    {
        // Add DKIM-Signature as a result object from verifyDKIM

        if (is_array($mime))
        {
            foreach ($mime as $signature)
                return $this->addDKIMSignature($signature);
        }

        foreach ($mime->getHeaders("DKIM-Signature", ["field" => true]) as $i => $dkimsign)
        {
            if ($i >= 5) break;

            $this->addDKIMSignature($mime->verifyDKIM($dkimsign));
        }

        return $this;
    }

    function DMARC($dmarc, $ptypes = none)
    {
        $p = $dmarc["result"];

        switch ($p)
        {
            case "none":
            case "reject":
            case "quarantine":
                $p = "fail";
                break;
            case "policy_absent":
                $p = "none";
                break;
        }
        $this->authresult["dmarc"]["result"] = $p;
        if ($dmarc["pdomain"]) $this->authresult["dmarc"]["ptype"] = ["header.from" => $dmarc["pdomain"]];

        if (is_array($ptypes)) $this->authresult["dmarc"]["ptype"] += $ptypes;
        return $this;
    }

    function addMethod($name, $result, $ptypes = [])
    {
        $this->authresult[$name] = ["result" => $result, "ptype" => $ptypes];
        return $this;
    }

    function toString()
    {
        $result = $this->hostname.";";

        if (length($this->authresult))
        {    
            foreach ($this->authresult as $method => $i)
            {
                foreach (isset($i["result"]) ? [$i] : $i as $t)
                {
                    $result .= "\r\n\t$method=".$t["result"];
                    if (is_array($t["ptype"]))
                    {
                        foreach ($t["ptype"] as $ptype => $value)
                        {
                            $result .= " $ptype=$value";
                        }
                    }
                    $result .= ";";
                }
            }
        } else {
            $result .= " none";
        }

        return $result;
    }
}